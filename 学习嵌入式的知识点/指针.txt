指针是什么? 

      指针本身是一个变量，它存储的是数据在内存中的地址而不是数据本身的值。它的定义如下: 

 int  a=10,*p;    
 p=&a


 int a=10;
 int *p=&a;
 

       首先我们可以理解 int* 这个是要定义一个指针p，然后因为这个指针存储的是地址所以要对a取地址(&)将值赋给指针p，也就是说这个指针p指向a。

      很多新手都会对这两种定义方法感到迷惑，其实他俩的意思是一样的。第一种定义方法定义了int型的变量a和指针p，然后将a的地址赋给p。第二种是在定义指针p的同时将a的地址赋给指针p。我们姑且理解为" int * "是定义指针的标志。

 

 

     

指针有什么用？

   这样我们就可以通过*p来找到指针所指向的变量a的地址，然后对地址中的值(值是10)进行操作。

//接着上面的代码

printf("%p",p)      //结果是一个地址(p指向的变量a的地址)。
printf("%d",*p)    //结果是10，变量a的值。
printf("%d",&p)   //结果是一个地址(指针p的地址，因为指针也是一个变量自己也有地址的)
 

数组名和指针的区别？

  数组名是一个地址，它可以被理解为一个常指针(它只能指向本数组首元素的地址)。而指针可以指其他的变量等等。

复制代码
int str[5]={1,2,3,4,5};
int *p=str;
printf("%d",*p);    //输出为1，数组的首元素。
printf("%d",*str);  //输出为1，数组的首元素。
printf("%d",str[0]);  //输出为1，数组的首元素。
printf("%p",p);  //输出为地址，数组的地址。
printf("%p",str);  //输出为地址，数组的地址。
printf("%d",*(p+1));  //输出为2，数组的第二个元素。
printf("%d",*(srt+1));  //输出为2，数组的第二个元素。
复制代码
对照代码大家可以很清晰的看到数组名在对内存中存储的数据进行操作的方法和结果是一样，但是数组名存储自己数组本身的首地址。

 

什么是空指针，野指针？

      在函数内部对指针进行赋值操作后，在函数执行完毕后，该指针就成了一个空指针(变量从栈中弹出)。但是通过动态地址分配(堆空间)的指针不会有上述问题。

        free(p)后释放内存的指针为野指针。

 

关于const对于指针的限制问题

      

复制代码
int a=10,b=20;
int * const p=&a;    //无法使p指向其他地址。
p=&b;                    //这样的操作是不允许的。
*p=20;                   //可以这样操作。

const int * p=&a;     //p可以指向其他地址。
p=&b;                      //可以操作。
*p=10;                     //操作不被允许。

const int * const p=&a   //p不能指向其他地址，也不能改变地址中的值。
p=&b;                      //操作不被允许。
*p=20;                     //操作不被允许。
复制代码
       总结：const在int的左边那就是不能修改地址中的值，在右边就是不能指向其他地址，左右都有那就是既不能修改地址的值也不能指向其他地址。 

       新手常出现的问题我个人总结了上述几点，如果有错误的地方希望大家留言交流互相学习。后面会写下多维数组的存储方式和指针的问题。